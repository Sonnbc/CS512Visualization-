conservation	submodular	budget	online auctions	action language	bidding auctions	winner determination	qualitative models	indirect	bidding	reasoning constraints	bid	anchoring	auctions	combinatorial auctions	algorithm stochastic	knapsack	qualitative reasoning	qualitative networks	learning actions	iterated	qualitative temporal reasoning	introspective	action representation	combinatorial	procedure	coalitional	causality	acts	coalitional games	qualitative	time knowledge	reasoning uncertain	diagnostic model	play	interactive influence	argumentation	bound learning	reasoning action	theory	nash equilibria	knowledge qualitative	reasoning time	complexity games	equilibria games	nash	inferences	temporal relations	membership	equilibrium games	equilibrium	equilibria	pure	poker	qualitative decision	unique	generating explanations	automated abstraction	qualitative theory	learning games	case-based	strategy games	topology	simulating	general-sum	games	decision theory	imperfect games	plan recognition	real-time strategy games	imperfect	sum	multiagent planning	zero-sum games	dynamics	general reasoning	action planning	bargaining	partially observable domains	process theory	temporal projection	computationally	abstraction	multiple agents	description language	information games	optimally	winning	mixed	self-explanatory	terrain	stochastic games	theory resolution	symmetric	theorems	partially observable stochastic	player	game-theoretic	knowledge action	actions effects	channel	repeated	generation optimization	cumulative	game tree	action	qualitative modeling	reasoning domains	qualitative analysis	action model	game search	fluents	action approach	kinematics	model plan	reasoning games	narrative	strategic	tournament	surveillance	game playing	playing	computational approach	interacting	general game	computational theory	domain independent	general game playing	coalition structure generation	successful	generating	approach generating	reasoning calculus	temporal events	modeling theory	rewards	coalition formation	human-robot interaction	human-robot	concrete	mathematical	mathematics	general	success	generating plans	pareto	generalized trees	structure generation	computational model	coalition	situations	decision-making	computational framework	events	computational aspects	rational	dominance	generating descriptions	team	rationality	acting	ellipsis	computational semantics	behavior robot	evaluation functions	computational	generation expressions	monotonicity	soccer	reasoning agents	dialogs	influence diagrams	referring	explanation-based generalization	formation	computational linguistic	computational complexity	
automatic programs	computed	constraint programming	disjunctive	decomposition methods	loop	synthesis programs	separable	restricted	coordinate	propagation algorithm	compute	bounded	equivalent	symmetries	recursions	approximate iteration	closing	compiling	learning extended abstract	connectionist	automatic methods	algorithm problem	reasoning problem	sat	structure linear	functional constraints	automatic synthesis	cost functions	semantic constraints	clique	constraint learning	preference aggregation	qbf	features data	preference	correspondences	optimal algorithms	ebl	relaxations	robots	decision graphs	planning problem	decision knowledge	skills	point-based	vulnerability	arc consistency	synthesis	solvers	planning goal	arc	quantified boolean	mixed-initiative	optimal problems	multi-armed	cut	stochastic search	policy iteration	approach solving	decentralized	iteration	consistency csp	consistency constraints	deadlines	local weighted	anytime	based ontology	consistency weighted	weighted csp	irrelevance	approximation algorithm	graphs knowledge	high-order	analogical	admissible heuristics	stochastic local search	algorithms prediction	local global	equation	framework results	multi-view clustering	linear stochastic	stochastic gradient	phase transitions	combining local	linear algorithms	gradient descent	transitions	problem-solving	local consistency	mpe	subgoals	differential equations	domain-independent	constraint propagation	space	decomposition constraint	global analysis	geospatial	spread	descent	complexity constraint satisfaction	local search	line	bandit problems	local	phase problems	np	drawings	search solving problems	dynamic constraint satisfaction	parameterized	search constraint satisfaction	constraint based	local problems	space approach	contract algorithms	solution	quantified	utility elicitation	life	line drawings	lookahead	learning analogical	contract	preference elicitation	results problems	approach problem	networks constraints	temporal domain	utility problem	combination learning	search problems	weighted constraint	experimental algorithms	structured problems	satisfiability problems	solving search	algorithms results	iteration pomdps	algorithms application	solving constraint satisfaction problems	search constraint	evaluation problems	sat-based	class problems	quantified constraint	dynamic constraint	constraint satisfaction problems	interpret	complexity constraints	automata	grammatical inference	faults	algorithms scheduling	bandit	algorithms problems	method problems	weighted	scheduling problems	propositional satisfiability	figures	phase	formulae	solving constraint problems	global	reasoning solving	regret	search scheduling	search satisfiability	modeling problem	inference rules	constraint problems	analysis problems	partial linear	intractable	csps	symmetry breaking	expected	solving stochastic	large scale linear	efficient representation	thing	pomdps	structural constraint	general problem	global constraint	solving algorithms	policy pomdps	heuristics	constraint constraints	constraint satisfaction	geometric constraint	large problems	solving problems	recycling	maximizing	solving constraint	hard problems	solving large	architecture learning	model problem	local coherence	hard	solution learning	solution problem	divide-and-conquer	learning heuristics	generation random	learning control knowledge	solving planning problems	constraint planning	control problem solving	constraint scheduling	decomposability	learning problems	disjunctions	advantage	decomposable	relation resolution	problem methods	problems models	space algorithm	search heuristics	document problem	efficient solving	diagnosing	problems	multiple methods	constraint-satisfaction problems	based pomdps	complexity problems	hardness	integration learning	iterative	generalized problem	similar approach	temporal problems	inference solving	event extraction	constraint	incremental knowledge	finite	analogical problem solving	control problem	soft	flexible learning	temporal constraint	inference problem	automatic constraints	version space	satisfiability	solving pomdps	constraint clustering	max-sat	solving	iterative algorithm	representation networks	acquiring	problem induction	problem space	learning solving	solving tasks	state automata	solving decision processes	learning problem solving	precedence	learning finite	finite state	approach constraint	finite automata	
guiding	reasoning space	domain theories	bounds	theorem proving	proving	version spaces	student	efficient inference	explanations	recovering	dialectical	complexity results	theorem	tractable	temporal reasoning	upper bound	qualitative quantitative	definite	upper	interactions	theorem prover	generating system	tight bounds	analysis reasoning	programs abstract	proof	student modeling	probabilistic inference	behavior-based	trees abstract	programs constraint	states	prover	formulas	restriction	bounds performance	stable	model-based	easy	algorithms reasoning	inconsistencies	existence	critique	theories action	geometric reasoning	constraint logic	tight	actions	guide	theory reasoning	reasoning	efficient reasoning	evidential	computational properties	magnitude	diagnosis causal	reasoning models	focusing	causal modeling	theory revision	golog	reasoning magnitude	theory causal	linear programs	made	belief change	abduction	interpretation reasoning	answer set	plausible	answer set programming	module	event calculus	reasoning multiple	account	successes	formal theory	causal	belief propagation	rules programming	learning inductive logic programming	epistemic	logic rules	equality	disjunctive feature	investigations	typed	logic grammars	multiple semantic	programming semantic	automatic programming	top-down bottom-up	direction	ignorance	reasoning networks	based tracking	learning programming	inductive data	bottom-up logic	efficient programming	programming multiple	inductive inference	interpretation	bottom-up logic programs	programming parsing	logic analysis	inductive logic programming	horn clauses	inconsistency	logic inference	intended	multiple inductive	causal theories	symbols	backtracking	consistency logic	logic abstract	generality	learning programs	model elimination	inference languages	sets logic programs	belief reasoning	feature logic	logic structures	causal reasoning	framework programming	logic semantic	combining logic	properties	logic programming	learning logic programs	nonmonotonicity	commonsense	linear logic	feature structures	reasoning based	analysis programming	programming approach	dynamic function	representing logic	framework logic	autoepistemic logic	logic programs	semantical	predicate invention	learning horn	protein-protein	propositional	argument	propositional logics	theories	equivalence programs	probabilistic reasoning	model logic	equivalence logic	logic beliefs	probabilistic logic	origin	elimination	clauses	inductive	subsumption	biases	first-order programs	programs	bounds complexity	revision	algorithm programming	priorities	programming	commonsense reasoning	revised	predicate logic	defeasible logic	complexity propositional	formalism	modal logics	probabilistic language	necessity	probabilistic causal	learning first-order	logic	many-sorted	belief	forgetting	prioritized	ilp	integer programming	horn	integer	backward	modal	belief revision	based programming	default logic	fuzzy logic	logic nonmonotonic	asymptotic	equivalence relations	general logic	predicate	preferential	clause learning	preferred	logic causal	wrong	dynamic programming	non-monotonic reasoning	defeasible	revising	inheritance reasoning	circumscription	defaults	non-monotonic logic	equivalence	description	first-order logic	conditional logic	stable models	belief functions	specificity	factored models	belief bases	contradiction	theory applied	programming planning	logic reasoning	epistemic logic	nonmonotonic reasoning	knowledge belief	abductive	lifted	default reasoning	expressing	unified view	relating	inheritance nonmonotonic	respect	nonmonotonic	reasoning programming	non-monotonic	atms	effectively	quantifying	higher-order	structure-based	possibilistic	stratified	fixed point	logic planning	possibilistic logic	first-order	constructive	debugging	entailment	harder	fixed	
decomposition	factored	belief state	shifting	coherence	tree applications	decomposition based	propagation	plan-based	cases	temporal recognition	q-learning	combining reasoning	tree decomposition	hypothesis	pathfinding	medical domain	encodings	algorithms complexity	algorithm class	based temporal	tractable temporal	learning reasoning	factored mdps	decision-theoretic	decomposition domain	generalizing	mechanical	reasoning preferences	constraint-based approach	structural approach	deep knowledge	age	optimal solutions	learning strategy	abstractions	planning constraints	reconstructing	constraint-based reasoning	durations	diagnostic	maximization	multiagent	classical	3-d motion	generation spatial	qualitative approach	probabilistic recognition	learning experimentation	variety	plan	learning stochastic	optimal	dynamic domains	stochastic approach	refinement learning	experimentation	planning effects	approach local	explanation learning	abstraction hierarchies	application planning	decomposition planning	reasoning large	explanation-based	abstracting	multi-robot	pruning based	partially ordered	ordering	symbolic approach	repair	handle	planning stochastic	stochastic domains	admissible	3-d	observation	qualitative simulation	sensing	real-world	abstraction planning	explanation-based approach	expected utility	stochastic	strategies planning	goal	splitting	motion planning	learning observation	narratives	planning satisfiability	limits	temporal domains	acquisition planning	dialogues	search extended	planning preferences	classical planning	responsibility	incremental acquisition	domain reasoning	analogy	domains	utility learning	framework planning	algorithm planning	preconditions	symbolic	search partial	planning execution	physical models	execution learning	heuristic	robot	search domains	planning models	camera	improvement	planning analysis	soar	probabilistic planning	abstraction learning	heuristics planning	planning goals	fast recognition	planning generation	partial order	preferences sets	modeling reasoning	planning robot	domain modeling	taking	rearrangement	planning space	total	optimal planning	nondeterministic	learning planning	conflict resolution	incremental planning	constraint-based	learning approach planning	conformant planning	planning nondeterministic domains	search state	settings	perception	heuristic search planning	worlds	diagnoses	inference search	monte-carlo	partial-order	explanation	planning multiple	complexity planning	htn	acquisition based	planning language	temporal planning	internal external	search planning	model robot	rules planning	state	approach	goal recognition	planner	motion	incremental approach	search control	search rules	learning search control	based planning	integrating planning	spatial robot	state inference	planning domains	planning extended	centering	planning uncertainty	control rules	integrated learning	goal-directed	transformational	approach acquisition	utility functions	approach planning	probabilistic environments	preferences	learning interactions	partial planning	response generation	hybrid	initial	planning state	symmetry	utility	inference approach	approach resolution	control planning	planning time	planning	utility planning	phonological	stereo	based plan	learning partial	learning control approach	plan planning	approximate planning	learning constraint-based	multiattribute	
